import path from 'path'
import { existsSync, readFileSync, readdirSync, statSync } from 'fs-extra'
import { BaseDepGraph } from './base'
import { deduplicateByName, saveModulesFile } from '../utils'
import { type DepGraph, DepGraphNode, modulesGraphOptions } from '../types'

// 不建议直接解析 node_modules，有几个问题：
// 1. IO 很多，性能很差
// 2. package.json 可能定义了范围版本，如 ^1.0.0，但实际安装的是具体版本：1.2.0，可能存在误差
// 3. 不同包管理器的安装结构差别很大，要兼容这么多情况，成本很高

const parsePackages = (depDef: any) => {
  const { dependencies, devDependencies } = depDef
  const packages: DepGraphNode['dependence'] = []
  if (dependencies) {
    Object.keys(dependencies).map((key) => {
      packages.push({
        name: key,
        version: dependencies[key],
        depType: 'dependencies',
      })
    })
  }
  if (devDependencies) {
    Object.keys(devDependencies).map((key) => {
      packages.push({
        name: key,
        version: devDependencies[key],
        depType: 'devDependencies',
      })
    })
  }

  return packages
}

const readPackageJson = (dir: string) => {
  try {
    // 所有文件操作改成异步
    const data = readFileSync(path.join(dir, 'package.json'), 'utf8')
    return JSON.parse(data)
  } catch (err) {
    console.error(`Error reading package.json in ${dir}:`, err)
    return null
  }
}

/* 
  depth为多少，则展示下钻第几层文件夹的结果，不包含之前的
*/
let jsonList: any[] = []
const traverseNodeModules = (rootDir: string, depth = 0, currentDepth = 0) => {
  if (currentDepth > depth) return
  if (existsSync(rootDir)) {
    readdirSync(rootDir).forEach((dependencyName) => {
      const dependencyDir = path.join(rootDir, dependencyName)
      // 判断文件是否是一个目录
      // 额。。。这种判断方式也不太靠谱，比如 pnpm 安装下来的目录结构里
      // 就不会吧 dep hoist 到根目录 
      if (statSync(dependencyDir).isDirectory()) {
        // 当递归层次到传递的最大深度时
        if (depth === currentDepth) {
          const packageJsonPath = path.join(dependencyDir, 'package.json')
          if (existsSync(packageJsonPath)) {
            const packageJson = readPackageJson(dependencyDir)
            jsonList.push(packageJson)
          }
        }

        // 在递归调用时，将 currentDepth 加一
        traverseNodeModules(dependencyDir, depth, currentDepth + 1)
      }
    })
  }
}

export class NodeModulesGraph extends BaseDepGraph {
  private depth?: number
  private savepath?: string

  constructor(options: modulesGraphOptions) {
    super()
    const { depth, savepath } = options
    this.depth = depth
    this.savepath = savepath
  }

  async parse(): Promise<DepGraph> {
    const pkgPath = path.join(process.cwd(), 'package.json')
    if (!pkgPath) {
      throw new Error(`The current directory does not exist package.json`)
    }
    const packageJson = JSON.parse(readFileSync(pkgPath, 'utf8'))
    const { dependencies, devDependencies } = packageJson

    const res: DepGraph['nodes'] = []
    jsonList = []
    await traverseNodeModules(process.cwd(), this.depth)
    jsonList.map((json) => {
      const { name, version } = json
      res.push({
        name,
        version,
        dependence: parsePackages(json),
      })
    })

    const deduplicateRes = deduplicateByName(res)
    if (this.savepath) {
      saveModulesFile(deduplicateRes, this.savepath)
    }

    return {
      nodes: deduplicateRes,
      dependencies: Object.keys(dependencies),
      devDependencies: Object.keys(devDependencies),
    }
  }
}
